#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "vcutils.h"

/* !!!!! Warning !!!!!
 * Please don't change the following constant unless absolutely necessary.
 * If ever changed, all documentation need to be changed correspondingly,
 * and all training effort will be destroyed. */
#define PHRASE_PER_GROUP (5)

int main(){
    /* Type 0.
     * Input: list of strings generated by a tokenizer.
     * Output: list of uint32_t representable integers in base 10.
     * n lines of input will generate ((n > 4) ? (n - 4) : 1) lines of output. */
    unsigned char *phrase = NULL;
    size_t size_phrase = 0;
    ssize_t len_phrase;

    unsigned char *phrase_list[PHRASE_PER_GROUP] = {NULL};
    size_t len_phrase_list[PHRASE_PER_GROUP] = {0};

    unsigned char *catphrase;
    size_t len_catphrase;
    size_t ptr;  /* Pointer used when concatenating phrases. */
    unsigned int not_null_phrase = 0;

    uint32_t hash;

    while ((len_phrase = getline((char **)(&phrase), &size_phrase, stdin)) != -1){
        strip_endl(phrase, &len_phrase);

        free(phrase_list[0]);
        for (unsigned int i = 0; i < PHRASE_PER_GROUP - 1; i++){
            len_phrase_list[i] = len_phrase_list[i + 1];
            phrase_list[i] = phrase_list[i + 1];
        }

        len_phrase_list[PHRASE_PER_GROUP - 1] = len_phrase;
        phrase_list[PHRASE_PER_GROUP - 1] = malloc((len_phrase + 1) * sizeof(char));
        memcpy(phrase_list[PHRASE_PER_GROUP - 1], phrase, len_phrase * sizeof(char));
        phrase_list[PHRASE_PER_GROUP - 1][len_phrase] = '\0';

        if (phrase_list[0] && len_phrase_list[0]){  /* Double insurance. */
            len_catphrase = 0;
            for (unsigned int i = 0; i < PHRASE_PER_GROUP; i++){
                len_catphrase += len_phrase_list[i] + 1;
            }
            catphrase = malloc(len_catphrase-- * sizeof(char));

            ptr = 0;
            for (unsigned int i = 0; i < PHRASE_PER_GROUP; i++){
                memcpy(catphrase + ptr * sizeof(char), phrase_list[i], len_phrase_list[i]);
                ptr += len_phrase_list[i];
                catphrase[ptr++] = '\0';
            }

            hash = str_hash(catphrase, len_catphrase);
            printf("%"PRIu32"\n", hash);
            
            free(catphrase);
        }
    }

    if (!phrase_list[0]){
        while (!phrase_list[not_null_phrase]){
            not_null_phrase++;
            if (not_null_phrase == PHRASE_PER_GROUP){
                /* Since not_null_phrase is increased one by a time, this is equal to
                 * if (not_null_phrase >= PHRASE_PER_GROUP) */
                break;
            }
        }

        if (not_null_phrase < PHRASE_PER_GROUP){
            len_catphrase = 0;
            for (size_t i = not_null_phrase; i < PHRASE_PER_GROUP; i++){
                len_catphrase += len_phrase_list[i] + 1;
            }
            catphrase = malloc(len_catphrase-- * sizeof(char));

            ptr = 0;
            for (size_t i = not_null_phrase; i < PHRASE_PER_GROUP; i++){
                memcpy(catphrase + ptr * sizeof(char), phrase_list[i], len_phrase_list[i]);
                ptr += len_phrase_list[i];
                catphrase[ptr++] = '\0';
            }

            hash = str_hash(catphrase, len_catphrase);
            printf("%"PRIu32"\n", hash);
            
            free(catphrase);
        }
    }

    for (size_t i = 0; i < PHRASE_PER_GROUP; i++){
        free(phrase_list[i]);
    }
    free(phrase);

    return 0;
}
